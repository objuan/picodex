using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;

using Picodex.Vxcm;

namespace Picodex
{

    public class DFVolumeBuilder
	{

        public static GameObject CreateGameObject(DFVolume data, bool addRenderer, bool addCollider)
        {
            // Create our main game object representing the volume.
            GameObject volumeGameObject = new GameObject("DFVolume");

            //Add the required volume component.
          //  DFVolume dfVolume = volumeGameObject.GetOrAddComponent<DFVolume>();


            // Set the provided data.
            //  dfVolume.data = data;

          //  DFVolumeFilter volumeFilter = volumeGameObject.AddComponent<DFVolumeFilter>();
           // volumeFilter.volumeData = data;


            // Add the renderer and collider if desired.
            if (addRenderer) { volumeGameObject.AddComponent<DFVolumeRenderer>(); }
            if (addCollider) { volumeGameObject.AddComponent<DFVolumeCollider>(); }

            // Return the created object
            return volumeGameObject;
        }

  //      // We wish to enforce the idea that each voxel database (.vdb) should only be referenced by a single instance of VolumeData.
  //      // This avoids potential problems with multiple writes to the same database. However, Unity makes it difficult to enforce this
  //      // because it allows users to copy VolumeData with Object.Instantiate(), and more problematically it allows users to duplicate
  //      // VolumeData assets through the Unity editor. Therefore we use this dictionary to track whether a given filename is already 
  //      // in use and warn the user if this is the case.
  //      private static Dictionary<string, int > pathsAndAssets = new Dictionary<string, int >();

		///**
		// * It is possible for %Cubiquity voxel database files to be created outside of the %Cubiquity for Unity3D ecosystem (see the \ref pageCubiquityVsCubiquityForUnity
		// * "user manual" if you are not clear on the difference between 'Cubiquity and 'Cubiquity for Unity3D'). For example, the %Cubiquity SDK contains
		// * importers for converting a variety of external file formats into voxel databases. This function provides a way for you to create volume data
		// * which is linked to such a user provided voxel database.
		// * 
		// * \param pathToVoxelDatabase The path to the .vdb files containing the data. You should provide one of the following:
		// *   - <b>An absolute path:</b> In this case the provided path will be used directly to reference the desired .vdb file.
		// *   - <b>A relative path:</b> If you provide a relative path then is it assumed to be relative to the streaming assets folder, 
		// *   because the contents of this folder are included in the build and can therefore be accessed in the editor, during play 
		// *   mode, and also in standalone builds.
		// * \param writePermissions The initial write permissions for the voxel database.
		// */
		//public static VolumeDataType CreateFromVoxelDatabase<VolumeDataType>(string pathToVoxelDatabase, WritePermissions writePermissions = WritePermissions.ReadOnly) where VolumeDataType : DFVolumeData
		//{			
		//	VolumeDataType volumeData = ScriptableObject.CreateInstance<VolumeDataType>();
		//	if(Path.IsPathRooted(pathToVoxelDatabase))
		//	{
		//		volumeData.basePath = VoxelDatabasePaths.Root;
		//	}
		//	else
		//	{
		//		volumeData.basePath = VoxelDatabasePaths.Streaming;
		//	}
		//	volumeData.relativePathToVoxelDatabase = pathToVoxelDatabase;
		//	volumeData.writePermissions = writePermissions;
			
		////	volumeData.InitializeExistingCubiquityVolume();

		//	volumeData.RegisterPath();
			
		//	return volumeData;
		//}
		
		///**
		// * Creates an empty volume data instance with a new voxel database (.vxcm) being created at the location specified by the optional path.
		// * 
		// * \param region A Region instance specifying the dimensions of the volume data. You should not later try to access voxels outside of this range.
		// * \param pathToVoxelDatabase The path where the voxel database should be created. You should provide one of the following:
		// *   - <b>A null or empty string:</b> In this case a temporary filename will be used and the .vdb will reside in a temporary folder.
		// *   You will be unable to access the data after the volume asset is destroyed. This usage is appropriate if you want to create 
		// *   a volume at run time and then fill it with data generated by your own means (e.g. procedurally).
		// *   - <b>An absolute path:</b> In this case the provided path will be used directly to reference the desired .vdb file. Keep in mind that
		// *   such a path may be specific to the system on which it was created. Therefore you are unlikely to want to use this approach in
		// *   editor code as the file will not be present when building and distrubuting your application, but you may wish to use it in
		// *   play mode from a users machine to create a volume that can be saved between play sessions.
		// *   - <b>A relative path:</b> If you provide a relative path then is it assumed to be relative to the streaming assets folder, where the
		// *   .vdb will then be created. The contents of the streaming assets folder are distributed with your application, and so this
		// *   variant is probably most appropriate if you are creating volume through code in the editor. However, be aware that you should not
		// *   use it in play mode because the streaming assets folder may be read only.
		// */
		//public static VolumeDataType CreateEmptyVolumeData<VolumeDataType>(Vector3i size, string pathToVoxelDatabase = null) where VolumeDataType : DFVolumeData
		//{			
		//	VolumeDataType volumeData = ScriptableObject.CreateInstance<VolumeDataType>();

		//	if(String.IsNullOrEmpty(pathToVoxelDatabase))
		//	{
  //              // No path was provided, so create a temporary path and the created .vxcm file cannot be used after the current session.
  //              string pathToCreateVoxelDatabase = PathUtils.GenerateRandomVoxelDatabaseName();
		//		volumeData.basePath = VoxelDatabasePaths.Temporary;
		//		volumeData.relativePathToVoxelDatabase = pathToCreateVoxelDatabase;	
		//		volumeData.writePermissions = WritePermissions.ReadWrite;
		//		volumeData.hideFlags = HideFlags.DontSave; //Don't serialize this instance as it uses a temporary file for the voxel database.
		//	}
		//	else if(Path.IsPathRooted(pathToVoxelDatabase))
		//	{
		//		// The user provided a rooted (non-relative) path and so we use the details directly.
		//		volumeData.basePath = VoxelDatabasePaths.Root;
		//		volumeData.relativePathToVoxelDatabase = pathToVoxelDatabase;
		//		volumeData.writePermissions = WritePermissions.ReadWrite;
		//	}
		//	else
		//	{
		//		// The user provided a relative path, which we then assume to be relative to the streaming assets folder.
		//		// This should only be done in edit more (not in play mode) as stated below.
		//		if(Application.isPlaying)
		//		{
		//			Debug.LogWarning("You should not provide a relative path when creating empty volume " +
		//				"data in play mode, because the streaming assets folder might not have write access.");
		//		}

		//		// As the user is providing a name for the voxel database then it follows that they want to make use of it later.
		//		// In this case it should not be in the temp folder so we put it in streaming assets.
		//		volumeData.basePath = VoxelDatabasePaths.Streaming;
		//		volumeData.relativePathToVoxelDatabase = pathToVoxelDatabase;
		//		volumeData.writePermissions = WritePermissions.ReadWrite;
		//	}
			
		//	volumeData.InitializeEmptyVolume(size);

		//	volumeData.RegisterPath();
			
		//	return volumeData;
		//}


	}
}
